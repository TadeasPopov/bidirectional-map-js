!function(t,e){if("object"==typeof exports&&"object"==typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var s=e();for(var n in s)("object"==typeof exports?exports:t)[n]=s[n]}}(this,(function(){return(()=>{"use strict";var t={d:(e,s)=>{for(var n in s)t.o(s,n)&&!t.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:s[n]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e)},e={};t.d(e,{default:()=>i});class s extends Error{}function n(t,e,s,n){if(e&&e.constructor!==n)throw new TypeError(`${t}: ${e} must be of type ${s}`)}class i{constructor(t=null,e=null){n("name1",t,"string",String),n("name2",e,"string",String),function(t,e,n,i){if(null!=e&&e===i)throw new s(`name1: ${e} and name2: ${i} must not be the same value`)}(0,t,0,e),this.map1=new Map,this.map2=new Map,this.name1=t,this.name2=e}set(t,e){null==t&&null==e||(null!=t&&(this.map1.has(t)?null==e?(this.map1.get(t).forEach((t=>{this.map2.set(t,[])})),this.map1.set(t,[])):this.map1.get(t).includes(e)||this.map1.get(t).push(e):this.map1.set(t,[e])),null!=e&&(this.map2.has(e)?null==t?(this.map2.get(e).forEach((t=>{this.map1.set(t,[])})),this.map2.set(e,[])):this.map2.get(e).includes(t)||this.map2.get(e).push(t):this.map2.set(e,[t])))}get(t,e){return n("name",t,"string",String),t===this.name1?this.get1(e):t===this.name2?this.get2(e):void 0}get1(t){if(this.map1.has(t))return 0===this.map1.get(t).length?null:1===this.map1.get(t).length?this.map1.get(t)[0]:this.map1.get(t)}get2(t){if(this.map2.has(t))return 0===this.map2.get(t).length?null:1===this.map2.get(t).length?this.map2.get(t)[0]:this.map2.get(t)}}return e.default})()}));